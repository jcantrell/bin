#!/bin/bash
#'ticket_path='/cygdrive/c/apocrypha/home/jordan/.tickets/'
#ticket_path='/home/jordan/.tickets/'
#ticket_path='/home/jordan/.tickets/'
source ~/.bashrc
ticket_path=~/.tickets/

list()
{
	# Wrap each argument in double quotes, 
	# and precede it with '-e ' (except '-v')

	[[ $# == 0 ]] && args="\"\"" || args=""
	for var in "$@" ; do
	    [[ "$var" != "-v" ]] && args=$args" -e";
	    args=$args" \"$var\"";
	done

	# Grep for given arguments in openlist, sort by ticket number

	eval "grep $args ${ticket_path}data/openlist"
}

view()
{
	if (($# ==  0)); then
		echo "Usage: tickets view n1 n2 n3 ..."
	else
		[[ -e "$ticket_path"data/open/"$1" ]] && \
      cat "$ticket_path"data/open/"$1" || \
      cat "$ticket_path"data/closed"/$1"
	fi
}

edit()
{
	if (( $#!=0 )); then
    ed "$ticket_path"data/open/"$1" \

  	# Update entry in openlist
  
  	#Remove old entry
  	sed "/^$1/d" -i ${ticket_path}data/openlist
  	
  	#Get new title of task
  	var=$(sed -n '/^title: /p' ${ticket_path}data/open/$1)
  
  	#Add new title to openlist
  	#echo $1" "$var >> ${ticket_path}data/openlist
    tickets refresh
  else
	  echo "Usage: tickets edit n"
  fi
}

new()
{
	if (( $# != 0)); then
		title=$1;
	else
		title="?";
	fi

  cf=${ticket_path}data/current

  if [ -f ${cf} ]; then
		c=$(( $(cat ${cf}) + 1))
	else
		c=1
	fi
  echo ${c} > ${cf}
	#f=${ticket_path}data/open/${c}
  f=${ticket_path}${c}

	echo -n "ticket: " >> ${f}
	echo ${c} >> ${f}
	echo -n "responsible: " >> ${f}
	echo ${USER}"@"$(hostname) >> ${f}
	echo "status: open" >> ${f}
  echo "priority: 0" >> ${f}
	echo "title: $title" >> ${f}
	echo -n "open date: " >> ${f}
	date >> ${f}
	echo "close date: " >> ${f}
  echo -n "scheduled: " >> ${f}
  date +" %M %H %d %m %w %Y" >> ${f}
	echo "man hours: " >> ${f}
	echo "----" >> ${f}
	echo "Describe the problem here" >> ${f}

  # Ticket exists in .tickets/ and .tickets/data/
  ln -s ${ticket_path}${c} ${ticket_path}data/open/${c}

	# Add an entry to openlist
	echo ${c}": 0: $title" >> ${ticket_path}data/openlist

	echo ${c}
	chmod 777 $f
}

recurring()
{
  action="$1"
  shift

	case "$action" in
  add)
    crondate="$1"
    title="$2"
    cf=${ticket_path}data/recurring/current
    c=0
    [[ -f ${cf} ]] && c=$(( $(cat ${cf}) + 1))
    echo ${c} > ${cf}
    f=${ticket_path}data/recurring/${c}
    echo "title: $title" >> ${f}
    echo "crondate: $crondate" >> ${f}
    chmod 777 $f
    tickets recurring reset
    echo ${c}
    ;;
  reset)
    for f in ${ticket_path}data/recurring/*; do
      [ -e "$f" ] || continue;
      [ ! "$f" == "${ticket_path}recurring/current" ] || continue;
      t=$(grep 'title: ' "$f" | sed 's/title: //')
      cd=$(grep 'crondate: ' "$f" | sed 's/crondate: //')


      croncommand="$cd /bin/bash -ci 'source "
      croncommand="$croncommand""\$HOME/.bashrc;"
      croncommand="$croncommand""tickets recurring activate ${f##*/}'"
      (crontab -l; echo "$croncommand") \
        2>/dev/null | uniq | crontab -
    done
    ;;
  remove)
    crontab -l | grep -v "tickets recurring activate $1" | crontab -
    rm ${ticket_path}data/recurring/$1
    ;;
  view)
    cat ${ticket_path}data/recurring/$1
    ;;
  list)
    #(for f in ${ticket_path}recurring/*; do
    #  [ -e "$f" ] || continue;
    #  [ ! "$f" == "${ticket_path}recurring/current" ] || continue;
    #  crontab -l | grep "tickets recurring activate ${f##*/}" | uniq
    #done) | uniq
    ls -I current ${ticket_path}data/recurring \
      | xargs head -n 2 \
      | sed '/^\s*$/d' \
      | sed 's/\(==> \)\|\( <==\)//g' \
      | sed 'N;N;s/\(.*\)\n\(.*\)\n\(.*\)/\1\
\3\
\2/' \
      | sed 'N;N;s/\n/ /g' \
      | sed 's/crondate: //'
    ;;
  activate)
    activateRecurring "$1"
    ;;
  *)
    echo -n "Usage: tickets recurring {add crondate title |"
    echo -n "remove recurId | activate recurId | list | reset}"
    echo
    exit 1
    ;;
  esac
}

activateRecurring()
{
  title=$(grep title ${ticket_path}data/recurring/$1 | sed 's/title: //')
  n=$(tickets new "$title")
  s="Describe the problem here"
  sed '/'"$s"'/d' -i ${ticket_path}data/open/$n # delete line matching s
  cat "$ticket_path"data/recurring/$1 | \
  sed '/title: /d' >> "${ticket_path}data/open/$n"
}

close()
{
	# To-do: what if ticket $n doesn't exist, or already closed?
	if (( $# != 0 )); then
		for ((n=1;n<=$#;n++))
		do
		  if [[ (! -e "${ticket_path}${!n}") ]]; then
        echo "Ticket ${!n} doesn't exist or is already closed!"
        continue
      fi
      
    	sed "/status: /s/.*/status: closed/" -i ${ticket_path}${!n}
    	sed "/close date: /s/$/$(date)/" -i ${ticket_path}${!n}
      if [[ -e "${ticket_path}data/open/${!n}" ]]; then
        rm ${ticket_path}data/open/${!n}
      fi
      if [[ -e "${ticket_path}data/scheduled/${!n}" ]]; then
        rm ${ticket_path}data/scheduled/${!n}
      fi
      ln -s ${ticket_path}${!n} $ticket_path"data/closed/"${!n}
			#mv ${ticket_path}data/open/${!n} $ticket_path"data/closed"

			# Remove from openlist
			sed "/"${!n}"/d" -i ${ticket_path}data/openlist
		done
	else
		echo "Usage: tickets close n"
	fi
}

# Resolve tickets with merge conflicts (determined by presend of '=======')
resolve()
{
  pushd ${ticket_path} >/dev/null

  grep -R -l --exclude-dir=.git --exclude-dir=data '^=======$' |
  while read t; do

    #t="$1" #ticket
    s=$(cat "$t" | grep -n '^<<<<<<< HEAD$' | cut -f1 -d:)
    m=$(cat "$t" | grep -n '^=======$'      | cut -f1 -d:)
    e=$(cat "$t" | grep -n '^>>>>>>>'       | cut -f1 -d:)

    t2=$(tickets new)
    sed -n -e "1,$((s-1)) p" \
           -e "$((m+1)),$((e-1)) p"\
           -e "$((e+1)),$ p"\
           "$t" >"$t2"

    sed -i -n -e "1,$((s-1)) p" -e "$((s+1)),$((m-1)) p" -e "$((e+1)),$ p" "$t"
  done;

  popd >/dev/null
}

# Refresh helpful datastructures in data/
# don't take care of timestamp here, that  is done on exit
refresh()
{
	# move all status: closed tickets to .tickets/closed, etc

  pushd ${ticket_path} >/dev/null

  rm -r data/{scheduled,open,closed}
  mkdir data/{scheduled,open,closed}
  ls -I.git -Idata | sort -V | tail -n 1 >data/current

	# Move open tickets
	#grep -R -l --exclude-dir=.git --exclude-dir=data 'status: open' \
	#	| xargs -I{} ln -s ${ticket_path}{} ${ticket_path}data/open \
  #    2>/dev/null

	grep -R -l --exclude-dir=.git --exclude-dir=data 'status: open' |
  while read i; do
    ln -s ${ticket_path}"$i" ${ticket_path}data/open
  done

	# Move closed tickets to closed
	#grep -R -l --exclude-dir=.git --exclude-dir=data 'status: closed' \
	#	| xargs -I{} ln -s ${ticket_path}{} ${ticket_path}data/closed \
  #    2>/dev/null
	grep -R -l --exclude-dir=.git --exclude-dir=data 'status: closed' |
  while read i; do
    ln -s ${ticket_path}"$i" ${ticket_path}data/closed
  done
 
  # Move scheduled tickets
  #grep -R -l --exclude-dir=.git --exclude-dir=data 'status: scheduled' |
  #xargs -I{} ln -s ${ticket_path}{} ${ticket_path}data/scheduled 2>/dev/null

	grep -R -l --exclude-dir=.git --exclude-dir=data 'status: scheduled' |
  while read i; do
    ln -s ${ticket_path}"$i" ${ticket_path}data/scheduled
  done
	
	# Create openlist
  grep -R -l --exclude-dir=.git --exclude-dir=data 'status: open' |
  while read i; do
    (head -n 9 $i | tr '\n' ';');
    echo;
  done |
  sed 's/ticket: \|responsible: \|status: \|priority: \|title: //g' |
  sed 's/open date: \|close date: \|scheduled: \|man hours: //g' |
  awk -F\; '{print $4 ";" $1 ";" $5}' |
  sort -V |
  awk -F\; '{print $2 ": " $1 ": " $3}' >${ticket_path}data/openlist

  popd >/dev/null
}

sync()
{
  pushd $ticket_path >/dev/null
  d=$(date +'%s')
  touch ${ticket_path}data/timestamp/"$d"
  find ${ticket_path}data/timestamp/ -type f -not -name "$d" -delete
  git add -A
  git commit -m "auto sync $(date)"
  git pull
  git push
  git pull
  popd >/dev/null
}

dup()
{
	if (($# ==  0)); then
		echo "Usage: tickets view n1 n2 n3 ..."
	else
    t="$1"
    n=$(tickets new)
    f=${ticket_path}${n}
    sed -i '1,/----/d' $f
    cat ${ticket_path}${t} >> $f
    sed -i '/ticket:/c\ticket: '$n $f
    # move ticketpath/data/status/n to appropriate status/ dir
    status=$(cat ${ticket_path}$n | sed -n '/status/p' | sed 's/status: //')
    if [[ $status == "scheduled" ]] ; then
      mv ${ticket_path}data/open/$n ${ticket_path}data/scheduled/$n
    fi
    if [[ $status == "closed" ]] ; then
      mv ${ticket_path}data/open/$n ${ticket_path}data/closed/$n
    fi
    sed -i '1d' $f
    echo "$n"
	fi
}

activate()
{
	if (( $#!=0 )); then
    n=$(tickets dup $1)
    echo "$n"
    d=$(date +" %M %H %d %m %w %Y")
    pushd ${ticket_path} >/dev/null
    sed -i "s/^scheduled: .*$/scheduled: $d/" "$n"
    sed -i "s/^status: scheduled$/status: open/" "$n"
    mv ${ticket_path}data/scheduled/${n} ${ticket_path}data/open/
    popd >/dev/null
  else
	  echo "Usage: tickets activate n"
  fi
}

condActivate()
{
  pushd ${ticket_path} >/dev/null

  then=$(ls ${ticket_path}data/timestamp/ | sort -V | tail -n 1)
  then=$(( ( then / 60 ) * 60 ))
  now=$(date +'%s')

  for (( i=$then; i<=$now; i+=60 )) ; do
    grep -R -l --exclude-dir=.git --exclude-dir=data 'status: scheduled' |
    while read f; do
      newpat=$(grep 'scheduled:' "$f" | sed 's/scheduled: //')
      idate=$(date -d@"$i" +'%M %H %d %m %u %Y')
      dateMatch.pl "$newpat" "$idate"
      match=$?
      if [[ "$match" -eq 1 ]]; then
        tickets activate "$f";
      fi
    done
  done

  popd >/dev/null
}

main()
{
  if [[ $# == 0 ]] ; then
    tickets list
    exit 0
  fi
  action="$1"
  shift

  recurse=false
  if [[ $action == "list" ]] ; then
    recurse=true
  fi

  if [[ $recurse == "true" ]] ; then
    tickets condActivate
  fi

	case "$action" in
	  list) # list tickets whose titles match a given regex
     # tickets condActivate
	    list "$@"
	    ;;
    view) # view a specific ticket
     # tickets condActivate
      view "$@"
      ;;
    edit) # edit a specific ticket
     # tickets condActivate
      edit "$@"
      ;;
    new) # create a new ticket
     # tickets condActivate
      new "$@"
      ;;
    close) #close a specific ticket
     # tickets condActivate
      close "$@"
      ;;
    refresh) # refresh assistive data structures (in data/)
     # tickets condActivate
      refresh "$@"
      ;;
    sync) # sync with server
      echo "sync"
      sync "$@"
      exit # Do not call sync() after this switch; that would be an inf. loop
      ;;
    dup) # duplicate a ticket (contents and title, not dates)
      dup "$@"
      ;;
    activate) # activate a scheduled ticket
      activate "$@"
      ;;
    condActivate)       # activate a ticket if it was scheduled between last run
      condActivate "$@" # and now
      tickets sync >/dev/null 2>&1 &
      ;;
    resolve)            # resolve tickets with merge conflicts
    #  tickets condActivate
      resolve "$@"
      ;;
    *)                  # list or view, or print usage message
      #tickets condActivate
      if [[ $action =~ ^[0-9]+$ ]] ; then
        tickets view $1
        exit 0
      fi
      
      usageStr="Usage: tickets <command> <parameters>\n"
      usageStr="\tlist RE\n\tview n\n\tedit n\n\tnew title\n\tweekly\n"
      usageStr+="\tclose n\n\trefresh\n\tsync\n\tdup n\n"
      echo -en "$usageStr"
      exit 1
	esac

  if [[ $recurse == "true" ]] ; then
    tickets sync >/dev/null 2>&1 &# push new timestamp
  fi
}

main "$@"
